https://www.youtube.com/watch?v=BoazgBZ4D7k
https://www.youtube.com/watch?v=6Ony27gzDHo

посмотреть позже пример собеса: https://www.youtube.com/watch?v=vO1VqfhMRnM
заучить как закодить типовые задачи (написать потом тут разными способами):
- факториал
# классический варинат
def fact(n):
    s = 1
    for i in range(1,n+1):
        s *= i
    return s

# рекурсивный в одну строку
def fact2(n):
    return 1 if n < 2 else n*fact2(n-1)

# с использованием reduce
from functools import reduce
def fact3(n):
    return reduce(lambda x, y: x*y, range(1,n+1), 1)

- фиббоначи
# рекурсивная функцию для чисел Фиббоначи в одну строку
def fib(n):
    return 1 if n < 3 else fib(n-1) + fib(n-2)

# вариарнт с использованием списка
def fib2(n):
    ans = [1,1]
    if n < 3:
        return 1
    else:
        for i in range(2,n):
            ans.append(ans[i-2] + ans[i-1])
        return ans[-1]

# и наконец самый быстрый вариант
def fib3(n):
    a, b = 1, 1
    if n < 3:
        return 1
    else:
        for i in range(2,n):
            a, b = b, a+b
        return b

- бинарный поиск 
def binary(arr, num):  # arr должен быть отсортированным списом чисел
    left, right = 0, len(arr)-1 
    while left <= right:
        mid = left + (right-left)//2
        if arr[mid] == num:
            return mid
        elif arr[mid] < num:
            left = mid + 1
        else:
            right = mid - 1
    return -1

рекуррентный вариант (хоть и не сильно отличающийся)
def rek_bin(arr, num, left, right):  # arr должен быть отсортированным списом чисел
    if right >= left:
        mid = left + (right - left)//2
        if arr[mid] == num:
            return mid
        elif arr[mid] < num:
            return rek_bin(arr, num, mid+1, right)
        else:
            return rek_bin(arr, num, left, mid-1)
    else:
        return -1

- даблсорт

- каунтер (посчитать сколько символов встречается в строке(?))


- Написать варианты основных способов сортировки и поисков по спискам(от себя)
1) пузырек
def bubble(arr):
    n = len(arr)
    for i in range(n-1):
        for j in range(n-i-1):
            if arr[j+1] < arr[j]:
                arr[j+1], arr[j] = arr[j], arr[j+1]
    return arr
1.2) сортировка расческой (производная от пузырьковой)
  Основная идея «расчёски» в том, чтобы первоначально брать достаточно большое расстояние между сравниваемыми элементами и по мере упорядочивания массива сужать это расстояние вплоть до минимального. Таким образом мы как бы причёсываем массив, постепенно разглаживая на всё более аккуратные пряди.
  Первоначальный разрыв между сравниваемыми элементами лучше брать не абы какой, а с учётом специальной величины называемой фактором уменьшения, оптимальное значение которой равно примерно 1,247. Сначала расстояние между элементами равно размеру массива разделённого на фактор уменьшения (результат, естественно, округляется до ближайшего целого). Затем, пройдя массив с этим шагом, мы снова делим шаг на фактор уменьшения и проходим по списку вновь. Так продолжается до тех пор, пока разность индексов не достигнет единицы. В этом случае массив досортировывается обычным пузырьком.

2) слиянием
def merge(arr1, arr2):
	I = len(arr1)
	J = len(arr2)
	i, j = 0, 0
	arr3 = []
	
	while i != I and j != J:
	    if arr1[i] <= arr2[j]:
		    arr3.append(arr1[i])
			i += 1
		else:
		    arr3.append(arr2[j])
			N += (I-i)
			j += 1
	
	if i == I:
	    for k in range(j, J):
		    arr3.append(arr2[k])
	else:
	    for k in range(i, I):
		    arr3.append(arr1[i])
	
	return arr3

def function(arr):
if len(arr) != 1:
 m = int(len(arr)/2)
		return merge(function(arr[:m]), function(arr[m:]))
	else:
		return arr


3) быстрая сортировка (quick sort)











Подтянуть рекурсию
Заучить SOLID
Повторить основные алгоритмы сортировки и их сложности (https://tproger.ru/translations/sorting-algorithms-in-python/?ysclid=lbwkr7mm3v797097469 или скопировать решения их курса на степике про алгоритмы)


0)Какая самая сложная задача, с которой довелось столкнуться в последний год, каким образом была разрешена?
Ответ:
…
(расписать рефакторинг воркфлоу … в sql процедуру на 8000 строк в целях оптимизации ночного техокна
И ту процедуру с распределением звонков роботу и сотруднику, но как-то поинтереснее расписать
Может стоит рассказать про задачу с госпошлинами)

Если спросят откуда черпаю новые знания, можно сказать про курсы, документацию (если нужно узнать про что-то конкретное), книги
0) Или просьба “Описать себя”
Ответ:
…

Если спросят про обучение, можно сказать про универ, степик, книги, конференции и так далее



1) Какие бывают типы данных в Python?
Ответ:
    Типы данных можно разделить на две группы: изменяемые и неизменяемые.
    К неизменяемым типам данных относятся int, float, string, bool, nonetype, tuple, frozenset    
    К изменяемым относятся list, dict и set

2) Какие типы данных относятся к изменяемым, какие нет? 
Ответ:
    см. ответ на вопрос 1 

3) Чем отличаются операторы == и is?
Ответ:
    «==» сравнивает 2 операнда по значениям, а «is» сравнивает их адреса в памяти.

4) Как в Python передаются аргументы в функцию (изменяемые и неизменяемые)?
Ответ:
    Неизменяемые типы передаются по значениям, а изменяемые по ссылкам.

5) Что такое args и kwargs? Чем представлены?
Ответ:
    args – это такой аргумент, который принимает в себя неограниченное количество позиционных аргументов функции; иммет тип tuple.
    kwargs – это аргумент, принимающий в себя неограниченное количество аргументов, которое мы передаём с помощью ключевых слов; имеет тип dict.
Их можно называть и иначе, просто это принято по умолчанию.


6) Что такое аннотации типов, зачем они нужны, когда выполняются?
Ответ:
    Аннотация типов это подсказки(ожидания) типов аргументов, переменных или чему-нибудь ещё. Их указание не ограничивает тип аргумента/переменной, они используются для упрощения чтения чужого кода. Современные IDE будут подсвечивать места с попыткой передачи аргумента не того типа, что указан в аннотации.
    Пример аннотации: def some_func(some_arg: list = [])


7) Что такое lambda функции? Кейсы применения
Ответ:
Lambda функция – это анонимная функция (функция без имени)
Может принять неограниченное число аргументов и содержит неявный return


8) Что такоре тернарный оператор, как записывается?
Ответ:
    Это if, написанный в одну строку (для лаконичности синтаксиса, улучшения читабельности).
    Пример: 
result = 1 if some_check else 0

9) Что такое глубокая и поверхностная копия? Зачем нужны? Как их сделать?
Ответ:
    Есть модуль copy с функциями copy и deepcopy, которые отвечают за поверхностную и глубокую копии соответственно. В случае изменяемых типов данных поверхностное копирование копирует внешний объект, он получает новый объем памяти, а у содержимого останутся прежние ссылки. В случае глубокого копирования изменяются так де и ссылки всего содержимого.

10) Что такое виртуальное окружение? Зачем оно нужно? Какие инструменты для этого используют?
Ответ:
    Своеобразная песочница, которая обособляет Pyhton и какую-то часть стандартных библиотек, для возможности работы в ней без «засорения» глобального Python.
    При создании нового проекта создают виртуальное окружение, там устанавливают все необходимые проекту зависимости и стартуют его в рамках данного виртуального окружения.
    (Чтобы различные Python проекты не мешали друг другу и не влияли на глобальный Python на ПК)
    Виртуальное окружение так же помогает избежать ошибок при обновлении библиотек глобального Pyhton.
    Инструменты: virtualenv и venv (этот встроен в Python3)

11) Poetry  (что это и какие преимущества над pip)
Ответ:
   Это аналогичный pip инструмент, который работает с зависимостями, пакетами и т.д. Преимущества: более удобное управление зависимостями, более удобный вывод дерева зависимостей, разрешение проблем проще (?). В общем, он имеет более удобный и более широкий функционал.

11.2) Вопросы касательно pip: как установить пакет (что прописать), откуда тянутся эти пакеты, зачем нужен файл requirements.txt
    pip install название_пакета
    pip берет пакеты с pypi.org
    В файле requirements.txt прописываются все зависимости проекта, при его наличии можно командой pip install –r requirements.txt установить все указанные зависимости


12) Как оценивается сложность алгоритмов и почему? Что такое Big O notation?
Ответ:
    Сложность алгоритмов оценивается с точки зрения Big O notation.
    Big O notation  - это оценка с точки зрения атомарных операций. С точки зрения математики можно описать O как верхнюю границу при неизвестности точной границы оценки (тетты).
...  (https://habr.com/ru/post/188010/)
Циклы или прохождение по списку это O(n), рекурсия обычно O(logn), цикл в цикле это O(n^2), а атомарные операции (присваивание, сложение, вычитание, …) это O(1)
…
O(1) < O(logn) < O(n) < O(n*logn) < O(n^2) < O(2^n) < O(n!)


13) Какая сложность основных операций в коллекциях?
Ответ:
#нужно понимать разницу между хеш-таблицами и обычными массивами

Поиск
 

Сортировка
 


Структуры данных
 

Кучи
 

Представление графов
 


14) Что такое self в классах?
Ответ:
    self – ссылка на текущий созданный уникальный объект класса
(класс – шаблон для уникальных экземпляров; объект – уникальный экземпляр класса)
(self пишется начальным аргументом всех функций объекта)


15) Зачем нужен метод super в классе?
Ответ:
    super – ссылка на объект родительской сущности. Нужен для доступа к родительским классам, когда есть наследование, например к функции родительского класса, если в текущем данная функция перегружена.
(super часто используется в магических (?) методах)

16) Как в python реализуются методы объекта, класса и статические методы? Чем они отличаются?
Ответ:
class A:
	def a(self):  #это метод объекта
		pass
	@classmethod
	def b(cls):
		pass
	@staticmethod
	def c():
		pass
    Методы объекта характеризуют поведение конкретного экземпляра какой-то сущности. Первым аргументом такого класса является self
    Методы класса создаются с помощью декоратора @classmethod. Первым аргументом они принимают cls – ссылку на класс.
    Статический метод создается с помощью декоратора @staticmethod. У статик метода нет обязательных аргументов
    Методы объекта можно использовать только создав объект, а статические методы и методы класса можно использовать сразу, без создания объектов.


17) В Python нет модификаторов доступа, все по умолчанию public. Как в python реализуются public, private и protected методы атрибутов?
Ответ:
    Обусловлено, что имена protected (доступные в рамках данного и дочерних классов) атрибутов указываются начиная с «_» (например _some_val = …). Современные IDE будут предупреждать при попытке использовать подобные атрибуты
    Private (доступный только в рамках данного класса) атрибуты пишут начиная с двойного «_», например __some_val = …, но для обращения к нему нужно писать a._A__some_val (где a – объект класса A) 

18) Чем отличается атрибут класса от атрибута объекта?
Ответ:


19) Что такое декораторы? Зачем нужны? Как реализовать в python простой декоратор и декоратор с пробросом аргумента?
Ответ:
    Декоратор — это функция, которая позволяет обернуть другую функцию для расширения её функциональности без непосредственного изменения её кода
(функции это объекты первого класса) (в Python-е всё объект)

    Функция может принимать в качестве аргумента другую функцию и возвращать её в качестве результирующего значения, на это соответственно в python и построены декораторы. Для декораторов в python есть выделенный «синтаксический сахар»(синтаксический сахар - это синтаксические возможности, применение которых не влияет на поведение программы, но делает использование языка более удобным для человека (например a += 1 вместо a = a + 1))

(в видео момент около 50:40)
def  decorator(func):
	def wrapper(*args, **kwargs) :
		result = func(*args, **kwargs)
		return result
	return wrapper
    чтобы применить декоратор с помощью синтаксического сахара:
@decorator
def some():
	pass
    либо без синтаксического сахара:
def some_2():
	pass

some_2_with_dec = decorator(some_2)

    Если нужно пробросить аргумент, то нужно добавить внешнюю функцию, которая принимает какой-то аргумент:
def outer(a = 1)
def  decorator(func):
	def wrapper(*args, **kwargs) :
		result = func(*args, **kwargs)
		return result
	return wrapper
	return decorator
    и тогда можно писать @outer(123) вместо @decorator(), а без синтаксического сахара будет:

dec = outer(123)
some_with_dec = dec(some_2)
либо в одну строку:
some_with_dec = outer(123) (some_2)
20) Что такое абстрактный класс? Зачем они нужны? Как они реализуются в Python?
Ответ:
    Абстрактный класс – это класс, у которого нельзя создать объект. В таких классах описывается контракт (в виде абстрактных методов), который должны реализовать дочерние классы.
    В Python, в отличии от других языков программирования, нет интерфейсов и для реализации «контрактов между классами» используются абстрактные классы.
    Для создания абстрактного класса:

from abc import ABC, abstractmethod

class A(ABC):
@abstractmethod
	def some():
		pass

  !Важно: пока в классе нет абстрактных методов, можно создать объект данного класса, но при наличии метода с декоратором @abstractmethod уже не получится создать объект, выдастся ошибка. Если новый класс наследуется от абстрактного класса и не переопределяет абстрактный метод, то он тоже остаётся абстрактным классом, и перестанет им быть только при переопределении абстрактного метода.

21) Что такое метаклассы? Для чего они используются? Какие методы там используются? Как реализовать на Python?
Ответ:
    Метакласс является шаблоном для классов. На основе метаклассов строятся классы (а на основе классов строятся объекты)
#метаклассы нужно использовать осторожно
    Метаклассы используются для того, чтобы перехватить создание классов и его как-то изменить, либо позже изменить какое-то его поведение.
    Выделяют в метаклассах 4 метода:
-	new
-	init
-	prepare
-	call
prepate подготавливает данные, которые потом попадают в new, там создается класс, init отвечает за его инициализацию, а call за создание объекта класса.
    Чаще всего в метаклассах переопределяется метод new.





    Реализация на Python:

from abc import ABC, abstractmethod, ABCMeta # для абстрактных классов 

class OneMeta(ABCMeta):
	pass

class Two(type): #для обычных классов
	pass
_______

class Two(type):
	def __new__(msc, name, bases, attrs, extra_kwargs): # набор стандартных аргументов отличается


22) Что такое ООП?
Ответ:
    ООП (объекто-ориентированое программирование) – парадигма программирования представляющая программу в виде объектов, которые каким-то образом взаимодействуют друг с другом. Всё, что угодно можно представить в виде объекта со свойствами и методами. Объекты являются экземплярами  классов, а классы – это шаблоны, в которых описаны все свойства будущего объекта и его методы

23) Какие базовые принципы ООП?
Ответ:
    Абстракция - отделение концепции от ее экземпляра (мы в коде используем только те характеристики объекта, которые нам важны конкретно в данном коде (основной принцип моделирования))
    Наследование – способность объекта или класса базироваться на другом объекте или классе (это главный механизм для повторного использования кода; наследственное отношение четко определяет их иерархию)
    Инкапсуляция – инкапсуляция в программировании понимается двояко: 1)фундаментально инкапсуляция это про то, что мы в класс должны поместить все атрибуты и методы, которые связаны общей идеей; 2) сокрытие данных(в классе должны быть преимущественно private или protected атрибуты, или, иначе говоря, не должно быть доступа к атрибутам класса, если в этом нет необходимости)
    Полиморфизм – перегрузка методов класса или модернизация родительских методов для возможности одинаковой обработки атрибутов с разными типами
(есть ещё второй вариант, канонический, это параметрический полиморфизм, но пока не знаю как его лучше описать, так же возможно называется «утиная типизация», если примерно, то «функции должны одинаково обрабатывать входящий атрибут, независимо от его типа »)

24) Что такое миксины?
Ответ:
        Миксин – это обычно небольшой класс, реализующий некоторый функционал для предоставления его множеству подклассов (наследников), но не предназначенный для создания экземпляров самого себя.


25) Что такое diamond ploblem? Что такое MRO? Чем отличается MRO2 от MRO3? Зачем оно нужно?
Ответ:
    diamond problem или проблема ромба – проблема, возникающая в языках со множественным наследованием, которая заключается в том, что 2 и более родительских класса могут иметь общего предка и в некоторых языках программирования сам язык программирования не знает как ему разрешить подобные зависимости
    В Python для подобных случаев есть решение под названием MRO (method resolution order – порядок разрешения методов) – жесткий порядок разрешения зависимостей проблемы ромба. MRO2, используемый в Python 2, был алгоритмом поиска в глубину (алгоритм идет сначала по ветке одного родителя до самого дальнего предка, далее идет по ветке следующего родителя), а MRO3, используемый в Python 3, используется алгоритм поиска в ширину (сначала смотрится текущий класс, потом все его родители, потом все их родители и т.д.).
    print(D.mro()) выведет список классов, представляющий в каком порядке в низ будет искаться какой-то метод/атрибут и т.п.


26) Что такое итератор? Что такое итерируемый объект?
Ответ:
    Итератор – структура данных (интерфейс), предоставляющий доступ к элементам коллекции (массива или контейнера) и навигацию по ним. В Python реализуется с помощью двух методов: iter (возвращает ссылку на итератор) и next (переводит указатель на следующий элемент итерируемого объекта). Эти 2 метода можно разнести по разным классам.
    Итерируемый объект – это такой объект, по которому можно пройтись поэлементно.









27) Что такое генератор? Как написать на Python генератор?
Ответ:
    Генератор – это некоторая функция, у которой вместо return будет yield и которая может принимать и отдавать контроль управления
(накопать подробнее про особенности работы генераторов и yield)
    Для написания генератора нужно выполнить генераторную функцию, получить объект генератора и далее с помощью next можно получать элементы данной последовательности, пока не закончатся yield-ы, а когда закончатся, получим stop iteration. Либо пихаем генераторную функцию в цикл и в цикле забираем все значения из генератора.
    Любой генератор является итератором (но не наоборот).


28) Что такое корутина?
Ответ:
    Корутина – это генератор с возможностью принимать ….
    Coroutine (корутины), или сопрограммы — это блоки кода, которые работают асинхронно, то есть по очереди.


..) Какие есть библиотеки для распараллеливания процессов?
	Ответ:
    На Python есть 3 библиотеки:
    - threading (в рамках одного процесса делим потоки, у потоков есть общая память и они выполняются конкурентно и необходимо ставить блокировки, чтобы безопасно работать с общей паматью)
    - multiprocessing (запуск программы в различных процессах, которые друг от друга не зависят; для мультипроцессинга необходима архитектура многоядерного процессора)
    - asyncio (…цикл по корутинам…)

    Когда какой используется:  «У нас есть различные типы ожиданий: I/O bound (ожидания ввода/вывода) и CPU-bound (когда программа зависит от скорости процессора). Если мы ждем задач выполнения от CPU, то нам подходит только multiprocessing, если мы ждем ввод/вывод, то мы можем использовать либо threading, либо asyncio: если версия Python 3.6 или выше и медленный ввод/вывод, то asyncio, если версия старее и быстрый ввод/вывод, то threading


29) Что такое async и await?
Ответ:
    async – 


..) Какие виды тестирования знаешь? Зачем писать тесты?
	Ответ:
    Виды тестов, реализуемые самим разработчиком:
    Юнит-тесты – тесты, которые тестируют мелкий функционал (класс, функцию или иной минимальный блок функционирующего кода)
    Функциональные тесты – тесты, которые тестируют связку каких-то компонентов (пакеты, andpoint на бэкенде(протестироват ссылку например) и т.д., иначе говоря тестируется результат некоторых действий)
    Интеграционные тесты – проверка всех доступов в окружении (к API, базам данных)
    Кроме того можно выделить ещё Сквозные тесты (копирование поведения пользователя при работе с ПО), Приемочные тесты (формальные тесты, которые проверяют, отвечает ли система требованиям бизнеса) и Тесты производительности (проверка работоспособности системы при определенных нагрузках)
    Тесты, по-хорошему, нужно писать всегда. Программисты должны писать минимум Unit-тесты (они самые дешевые и ими должно быть покрыто максимальное количество кода)


30) Какие модули в Python есть для тестирования? Какие отличия, плюсы и минусы?
Ответ:
    Встроенный в Python модуль Unittest, который импортирован с джавовского JUnit-а (интерфейс максимально дружелюбен в JUnit-у и потому разработчикам, привыкшим в JUnit, удобно)... 
    Плюсы:
- Встроен в Python и не будет внешней зависимости
- Используется некоторыми большими фреймворками по дефолту (например django)
    Минусы:
- Не PEP8 френдли
- Тестовые кейсы там представляют собой классы
- Функционал не такой широкий как у Pytest-а

    Второй инструмент это Pytest, инструмент от сторонних разработчиков, который нужно устанавливать (то есть это будет зависимость). Имеет широкий функционал. Есть хорошая работа с фикстурами (тестовые данные для unit-тестирования, могут быть как в базе, так и в файлах)
    Плюсы:
- Очень гибкий
- PEP8 френдли
- Тестовые кейсы это файлы, в которых атомарный кейс это функция, а не класс
- Удобная работа с фикстурами
- Наличие кучи батареек (?), которыми можно расширить функционал Pytest
    Минусы:
- Сторонняя разработка
33) Что такое mock? Зачем нужен?
Ответ:
    Иногда нам нужно избежать каких-то вызовов или каких-то сайд-эффектов, соответственно mock – это такой объект, который подменяет реальный объект, и мы ему можем задать ожидаемое поведение.
    (встроен в Unittest, а в Pytest есть pytest-mock (батарейка, которая прикручивает фикстуру по тесту для mock-ов))


34) Какие есть типы асинхронного выполнения? Какие библиотеки работают с асинхронным выполнением кода, в чем между ними разница?
Ответ:


35) Что такое ORM? С какими работал?
Ответ:


36) SQL Alchemy
Ответ:


37) Что такое GIL, какие проблемы он решает? Плюсы и минусы.
Ответ:
    GIL (Global Interpreter Lock) - блокировка, позволяющая только одному потоку управлять интерпретатором (в любой момент времени будет выполняться только один конкретный поток)
    Проблема, которую решает GIL, связана с тем, что в многопоточном приложении сразу несколько потоков могут увеличивать или уменьшать значения счётчика ссылок объекта. Это может привести к тому, что память очистится неправильно и удалится тот объект, на который ещё существует ссылка.
    Счётчик ссылок можно защитить, добавив блокираторы на все структуры данных, которые распространяются по нескольким потокам. В таком случае счётчик будет изменяться исключительно последовательно.
    Но добавление блокировки к нескольким объектам может привести к появлению другой проблемы — взаимоблокировки (англ. deadlocks), которая получается только если блокировка есть более чем на одном объекте. К тому же эта проблема тоже снижала бы производительность из-за многократной установки блокираторов.
    GIL — эта одиночный блокиратор самого интерпретатора Python. Он добавляет правило: любое выполнение байткода в Python требует блокировки интерпретатора. В таком случае можно исключить взаимоблокировку, т. к. GIL будет единственной блокировкой в приложении. К тому же его влияние на производительность процессора совсем не критично. Однако стоит помнить, что GIL уверенно делает любую программу однопоточной.
(https://tproger.ru/translations/global-interpreter-lock-guide/)
    Плюсы: обеспечивает безопасную работу с потоками
    Минус: из-за блокировки на уровне интерпретатора, Python по сути является только однопоточным на уровне CPU (GIL не вносит никакого эффорта на I\O bound), негативно влияет на производительность Python-программ из-за дополнительной нагрузки


38) Чем отличаются относительные импорты от абсолютных
Ответ:


BEST PRACTICES

39) SOLID, KISS, DRY
Ответ:
(почитать https://habr.com/ru/company/productivity_inside/blog/505430/)
    SOLID:
Single responsibility — принцип единственной ответственности (обозначает, что каждый объект должен иметь одну обязанность и эта обязанность должна быть полностью инкапсулирована в класс. Все его сервисы должны быть направлены исключительно на обеспечение этой обязанности)
Open-closed — принцип открытости / закрытости (декларирует, что программные сущности (классы, модули, функции и т. п.) должны быть открыты для расширения, но закрыты для изменения. Это означает, что эти сущности могут менять свое поведение без изменения их исходного кода. )
Liskov substitution — принцип подстановки Барбары Лисков (в формулировке Роберта Мартина: «функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа не зная об этом». )
Interface segregation — принцип разделения интерфейса (в формулировке Роберта Мартина: «клиенты не должны зависеть от методов, которые они не используют». Принцип разделения интерфейсов говорит о том, что слишком «толстые» интерфейсы необходимо разделять на более маленькие и специфические, чтобы клиенты маленьких интерфейсов знали только о методах, которые необходимы им в работе. В итоге, при изменении метода интерфейса не должны меняться клиенты, которые этот метод не используют.)
Dependency inversion — принцип инверсии зависимостей (модули верхних уровней не должны зависеть от модулей нижних уровней, а оба типа модулей должны зависеть от абстракций; сами абстракции не должны зависеть от деталей, а вот детали должны зависеть от абстракций)

    KISS – keep it simple, stupid (или более корректный «keep it short and simple».) – принцип, по которому рекомендуется не усложнять, когда есть возможность написать его проще и понятнее. (Принцип KISS утверждает, что большинство систем работают лучше всего, если они остаются простыми, а не усложняются. Поэтому в области проектирования простота должна быть одной из ключевых целей, и следует избегать ненужной сложности.)

    DRY – don’t repeat yourself – рекомендуется избегать повторного написания кода, вынося в абстракции часто используемые задачи и данные, каждая часть кода или информации должна находиться в единственном числе в единственном доступном месте.

40) Какие знаешь паттерны проектирования, какие использовал
Ответ:

41) Conflict management
Ответ:



DATABASES

42) Какие NoSQL базы данных знаешь, с какими работал, кейсы использования, плюсы и минусы
Ответ:

43) Какие SQL базы данных знаешь, с какими работал, кейсы использования, плюсы и минусы
Ответ:

44) PK, FK
Ответ:

45) Типы связей. Как реализуется связь многого со многим? 
Ответ:
    - Один-к-одному
    - Один-ко-многим
    - Многие-ко-многим

46) Зачем нужны индексы?
Ответ:
    Для ускорения обработки часто используемых запросов

47) Зачем нужны триггеры?
Ответ:
    Для добавления автоматической постобработки при добалвении / удалении / изменении некоторой записи определенной таблицы

48) Что такое транзакции?
Ответ:

49) ACID
Ответ:

50) Уровни изолированности транзакции
Ответ:



Tools and Cloud

51) Git
Ответ:

52) JIRA
Ответ:

53) docker
Ответ:

54) AWS
Ответ:



WEB

55) веб-фреймворки
Ответ:

56) REST (RESTful)
Ответ:

https://pythonru.com/baza-znanij/voprosy-na-sobesedovanii-python



Что означает пространство имен?
Пространство имен представляет собой систему имен, которая используется для обеспечения уникальности наименования всех объектов в программе, чтобы избежать возможных конфликтов. В Python они реализованы как словари с именем в качестве ключа и объектом в качестве значения. В результате разные пространства могут давать своим объектам одинаковые имена.
Три типа пространства имен в Python:
1) локальное – локальные имена внутри функции
2) глобальное – состоит из имен различных импортированных пакетов/модулей, которые в настоящее время используются в проекте
3) встроенное – включает встроенные функции Python и встроенные имена для различных типов исключений


	Объясните разницу между списком и кортежем?
Список(list) изменяемый, а кортеж(tuple) – нет. Кортежи можно хешировать, как в случае создания ключей для словарей.
(tuple или (1,2,3) – по сути неизменяемый список)

	Чем отличается pickling и unpickling?
В Python модуль pickle принимает любой объект Python, преобразует его в строковое представление и выгружает его в файл с помощью функции dump. Такой процесс известен как pickling. Для этого процесса используется функция pickle.dump().
С другой стороны, процесс извлечения исходного объекта Python из сохраненного строкового представления называется unpickling. Для этого процесса используется функция pickle.load()

	Разница между генератором и итератором?
В Python итераторы используются для перебора группы элементов. Генераторы представляют собой способ реализации итераторов. В них применяется yield для возврата выражения из функции, но в остальном генератор ведет себя как обычная функция.
yield - …

	Как преобразовать число в строку?
Для десятеричных чисел можем использовать встроенную функцию str().
Для восьмеричных oct()
Для шестнадцатеричных hex()

	Есть ли в Python инструкция Switch или Case?
Нет, но её можно реализовать самостоятельно, например:
def switch(…):
	…
	…

	Как используется %s?
%s – это спецификатор формата, который преобразует любое значение в строку

	Есть ли в Python функция main()?
Есть, она выполняется автоматически всякий раз, когда мы запускаем скрипт. Если нужно изменить этот естественный порядок вещей, используется оператор if:
if __init__ == “main”:
	…

	Какой метод использовался до оператора «in» для проверки наличия ключа в словаре?
Метод has_key()

	Каковы ключевые особенности Python?
Python – это язык программирования общего назначения высокого уровня с открытым исходным кодом. Поскольку это язык программирования общего назначения и он поставляется с большим набором библиотек, возможно использовать Python для разработки практически любого типа приложений.
Некоторые из его ключевых особенностей:
- интерпретированный - …
- с динамической типизацией - …
- объектно-ориентированный
- англоязычный синтаксис

	Объясните управление памятью в Python
В Python диспетчер памяти заботится об управлении памятью. Он выделяет её в виде пространства в куче, в которой хранятся все объекты Python и структуры данных. В языке существуют 4 встроенных структуры данных. Данное пространство недоступно для программиста напрямую, однако базовый API позволяет разработчику получить доступ к некоторым инструментам для написания кода.
Кроме того, Python оснащен встроенным сборщиком мусора (garbage collector), который освобождает неиспользуемую память из пространства кучи.

	Что такое PYTHONPATH?
PYTHONPATH – это переменная окружения, которая используется для включения дополнительных каталогов при импорте модуля/пакета. Каждый раз, когда модуль/пакет импортируется, PYTHONPATH используется для проверки наличия добавляемых модулей в существующих каталогах. Обычно интерпретатор использует PYTHONPATH чтобы определить какой модуль загрузить.

	Объясните использование функций help() и dir()
В Python функция help() используется для отображения документации по модулям, классам, функциям, ключевым словам и так далее. Если help() не получает параметров, она запускает интерактивную справочную утилиту на консоли.
Функция dir() возвращает допустимый список атрибутов и методов объекта, к которому она вызывается. Поскольку функция предназначена для получения наиболее релевантных данных (вместо отображения полной информации), она ведет себя по-разному с разными объектами:
- для модулей/библиотек функция dir() возвращает список всех атрибутов, содержащихся в этом модуле
- для объектов класса dir() вернет список всех допустимых атрибутов и базовых атрибутов
- когда ей не передаются никакие параметры, функция dir() возвращает список атрибутов в текущей области видимости

	Что такое модули Python
Модули – это файлы с расширением .py, содержащие код на Python, который представляет собой либо функциональные классы, либо переменные. Они могут включать в себя набор функций, классов или переменных, которые определены и реализованы. Их можно импортировать и инициировать с помощью инструкции import.
Наиболее часто используемые встроенные модули:
- os
- sys
- math
- random
- datetime
- JSON

	Объясните что означает «self» в Python
self – это ключевое слово, применяемое для определения экземпляра или объекта класса. В отличии от Java, где self не является обязательным, в Python он используется как первый параметр. Self помогает отличать методы и атрибуты класса от его локальных переменных.
Переменная self в методе __init__ ссылается к созданному объекту или экземпляру, тогда как в других методах она указывает на объект или экземпляр, метод которого был вызван.





